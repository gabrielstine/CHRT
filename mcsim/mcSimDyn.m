function [simData,simOptions] = mcSimDyn(scohFcn,simOptions,varargin)
%MCSIMDYN generate 1D Choice & Reaction Time data using Monte Carlo method
%   [simData,simOptions] = mcSimDyn(scohFcn,simOptions,varargin) generate
%   1D Choice & Reaction Time data using Monte Carlo method. The signed
%   coherence data is calculated from function handle instead of distinct
%   known values. This is different from mcSim function cause signed
%   coherence is a distribution.
%   where
%       scohFcn is user supplied function handle to generate random signed 
%       coherence from known distribution,
%       simOptions is Monte Carlo simulation options generated by
%       MCSIMOPTIONS function,
%       varargin are 'field' & 'value' pairs to update simOptions fields,
%       and
%       simData is Choice & Reaction Time data generated and sorted by
%       trial. Each row is signed coherence, choice and reaction time.
%
%   See also MCSIMOPTIONS, GETPROFILEFCN and MCSIM.

%   Copyright 2014 Jian Wang

if nargin < 2
    error('Not enough inputs.');
end

if nargin > 2
    simOptions = updateOptions(simOptions,varargin{:}); % Update options.
end

% Set time step size.
dt = simOptions.dt;    
if dt > 1.0E-3 % Unit of second.
    warning('Time step size is too coarse.');
end

tMax = simOptions.tMax; % Unit of second.
t = 0:dt:tMax;

% Set random number generator seed.
if isempty(simOptions.rngSeed) 
    rngSeed = rng;
    simOptions.rngSeed = rngSeed;
else
    rngSeed = simOptions.rngSeed;
end
rng(rngSeed);

% Set number of trials per signed coherence.
trials = simOptions.trials;

% Load theta inputs.
theta = simOptions.theta;

kappa = theta(1);
cohBias = theta(2);
uBias = theta(3);
sigma = theta(4);
bSigma = theta(5);
tndr = theta(6);
tndrsd = theta(7);
tndl = theta(8);
tndlsd = theta(9);

% Calculate up-boundary profile.
upBoundaryProfile = getProfileFcn(simOptions.upBoundaryProfile);
b = simOptions.upBoundaryParameter;
Bup = feval(upBoundaryProfile,b,t);

if isnan(b(1))
    error('Valid up boundary parameter must be provided.');
end

% Stop boundary collapsing when the boundary height become less than 0.1% 
% of initial value.
Bup(Bup <= b(1)*1e-3, 1) = b(1) * 1e-3;

% Calculate lower-boundary profile.
lowerBoundaryProfile = getProfileFcn(simOptions.lowerBoundaryProfile);
b = simOptions.lowerBoundaryParameter;
Blower = feval(lowerBoundaryProfile,b,t);

if isnan(b(1))
    error('Valid up boundary parameter must be provided.');
end

Blower(Blower <= b(1)*1e-3, 1) = b(1) * 1e-3;
Blower = -1.0 * Blower; % Inverse to make defining boundary profile easier.

% Monte Carlo Simulation
nt = length(t);

BupMatrix = Bup';
BlowerMatrix = Blower';

simData = zeros(trials,3); % Matrix of [scoh,lo 0/up 1, ndt]

for n1 = 1:trials
    scoh = feval(scohFcn); % Generate signed coherence from function handle.
    drift = kappa*(scoh + cohBias) + uBias; % Drift term (mu)
    dfu = sqrt(sigma^2 + bSigma * abs(scoh)); % Standard deviation (sd)
    mu = drift * dt;
    sd = dfu * sqrt(dt); % Standard deviance is calculated in this way to make
                         % sum(variance) = 1 per second.
                    
    dftForce = normrnd(mu,sd,nt-1,1);    
    dftSum = [zeros(1,1); cumsum(dftForce,1)];
        
    dftBup = dftSum >= BupMatrix;
    dftBlo = dftSum <= BlowerMatrix;
    
    tndrA = normrnd(tndr,tndrsd,1,1);
    tndlA = normrnd(tndl,tndlsd,1,1);
    
    
    iu = find(dftBup,1,'first'); % Index of hitting up bound
    il = find(dftBlo,1,'first'); % Index of hitting lo bound
        
    if isempty(iu) && isempty(il)
        choice = NaN;
        ndt = NaN;
    elseif ~isempty(iu) && isempty(il)
        choice = 1;
        ndt = (iu-1) * dt + tndrA;
    elseif isempty(iu) && ~isempty(il)
        choice = 0;
        ndt = (il-1) * dt + tndlA;
    elseif ~isempty(iu) && ~isempty(il)
        if iu <= il
            choice = 1;
            ndt = (iu-1) * dt + tndrA;
        else
            choice = 0;
            ndt = (il-1) * dt + tndlA;
        end
    end
        
    simData(n1,:) = [scoh,choice,ndt];    
end


